//////////////////////////////////////////////////////////////////////////////////////////
/// Выведение, приведение, и сравнение типов
//////////////////////////////////////////////////////////////////////////////////////////

fn explain_types() {
    // По умолчанию целочисленные типы определяются как i32.
    let a = 3;

    // Десятичные литералы определяют тип переменной как f64.
    let b = 3.14;

    // Можно явно задавать типы так:
    let c: i64 = 4;
    let d: f64 = 3.33;
    let e: bool = false;

    // К численным литералам можно добавить суффикс, чтобы явно задать тип переменной.
    let f = 3i64; // f: i64
    let g = 3f32; // g: f32

    ///////////////////////////////////////////////////////////////////////////////////////

    // Когда компилятор знает контекст использования переменной,
    // он может сам определить тип переменной, если он может быть выведен однозначно.

    // Здесь мы не задаем тип явно. По умолчанию, `h` будет i32.
    let h = 13;

    // Но дальше мы используем `h` в контексте, где может быть употребим только `i64`.
    // Мы задали для `i` тип `i64`, а значит, справа может стоять только выражение с типом `i64`.
    let i: i64 = h;
    // Раз мы не задали тип для `h` явно, то компилятор может взять это в свои руки
    // и вывести тип `h` как `i64`, потому что мы используем его в дальнейшем как `i64`.

    // Но если `h` употребляется к контекстах, где ожидаются разные типы, то компилятор
    // уже выдаст ошибку, потому что нельзя никак корректно определить тип для `h`.
    let j: i8 = h;

    ///////////////////////////////////////////////////////////////////////////////////////
 
    // Сравнения различных типов по умолчанию запрещены. Например, вы не можете сравнить
    // i32 и i64
    let k: i32 = 3;
    let m: i64 = 3;
    if k == m { // Compilation error: `k и `m` разных типов.
        println!("equals!");
    }

    // Чтобы привести один тип к другому можно использовать оператор `as`.
    // Какие правила работают при использовании `as` с разными типами
    // читайте в Rust Reference: https://doc.rust-lang.org/stable/reference/expressions/operator-expr.html#type-cast-expressions

    // Приводим `k` к i64
    if k as i64 == m {
        println!("equals!");
    }
}

//////////////////////////////////////////////////////////////////////////////////////////
/// Возвращаемые значения
//////////////////////////////////////////////////////////////////////////////////////////

// Тип возвращаемого значения функции i32
fn rand() -> i32 {
    // По умолчанию целочисленные типы определяются как i32.
    let x = 4;

    // Выражение в конце блока кода/функции является результатом этой функции или блока.
    // Его необязательно окружать словом return и точкой с запятой, хотя и можно.
    x // то же, что и `return x;`, но более идиоматично для Rust
}

// Если в сигнатуре функции не указан тип возвращаемого значения, как тут у `explain_returns`,
// то можно считать, что возвращается тип `()`.
// То есть `fn explain_returns() -> ();` и `fn explain_returns();` это одно и то же.
fn explain_returns() {
    // Инициализировать переменные можно результатом вычисления блока кода.
    let x = {
        let y = rand();
        // Значение `y` будет являться результатом блока кода и будет присвоено
        // переменной `x`.
        y
    };

    // А еще можно инициализировать переменные с использованием условий if-else.
    let y = if x == 4 {
        x * 2
    } else if x % 2 == 0 {
        x / 2
    } else {
        x / 2 + 1
    };

    // И даже циклами.
    let z = loop {
        let result = rand();
        if result == 4 {
            // Значение result становится результатом работы цикла
            // и присваивается переменной `z`.
            break result;
        }
    };

    // Точку с запятой в конце выражения можно не писать,
    // и это будет работать, потому что это *последнее* выражение в функции exaplain_returns
    // и тип результата совпадает с типом возвращаемого значения функции explain_returns - `()`.
    println!("Hello, world!")
}

//////////////////////////////////////////////////////////////////////////////////////////
/// Скоупы переменных и shadowing
//////////////////////////////////////////////////////////////////////////////////////////

fn explain_scopes_and_blocks() {
    // Каждая переменная имеет свой скоуп и живет до конца блока кода, в котором она объявлена.
    // Блок - это набор выражений, заключенных между фигурными кавычками {}.

    // Переменная `x` живет до конца функции.
    let x = rand();

    // Это новый блок кода, который живет внутри блока функции explain_scopes_and_blocks
    // и, соответственно, имеет меньший скоуп. 
    {
        // Переменная `y` будет жить до конца этого блока.
        let y = x;
    }
    // Конец блока.

    // Compilation error: мы вышли из скоупа, где объявлена переменная `y`,
    // ее жизнь закончена, в этом скоупе ее уже нет.
    println!("{y}");

    println!("{x}");

    // Здесь мы объявляем переменную с именем `x`, но уже с другим значением и даже типом.
    // Несмотря на то, что в этом скоупе уже есть переменная с именем `x`,
    // мы можем определить другую с таким же именем и использовать ее.
    // Это называется shadowing: предыдущая переменная становится недоступной по ее имени,
    // теперь `x` это уже другая переменная со значением `3.14` и типом `f64`.
    let x: f64 = 3.14;

    // Что интересно, объявляя переменную с уже использованным именем,
    // при вычислении ее начального значения, мы все еще можем обращаться к переменной
    // с именем `x` действующей до этой строки.
    // Например, тут справа от знака `=` мы используем переменную `x` типа f64
    // для вычисления значения переменной `x` типа i32.
    let x: i32 = x as i32; // = 3.14f64 as i32 = 3i32;
}

//////////////////////////////////////////////////////////////////////////////////////////
/// Макрос println 
//////////////////////////////////////////////////////////////////////////////////////////

// https://doc.rust-lang.org/std/macro.println.html
// https://doc.rust-lang.org/std/fmt/index.html

fn explain_println() {
    let x = rand();
    // println - это макрос, а не функция.
    // В кратце, макросы - это способ генерации кода на Rust на этапе компиляции.
    // Подробнее - последующих лекциях и семинарах.
    // В макрос println первым аргументом всегда передается форматная строка,
    // в которую можно вставить {}, на месте которых будет расположен соответствующий
    // аргумент.
    println!("Hello, {}!", x);

    // Можно аргументы вставлять прямо в {}, почти как в Python!
    // К сожалению, произвольные выражения вставить нельзя, только идентификаторы переменных.
    println!("Hello, {x}");

    println!("Hello, {get_name_func()}"); // Compilation error!

    // Как еще можно форматировать строки читайте тут: https://doc.rust-lang.org/std/fmt/index.html
}

//////////////////////////////////////////////////////////////////////////////////////////
/// Метки в циклах
//////////////////////////////////////////////////////////////////////////////////////////

// https://doc.rust-lang.org/reference/expressions/loop-expr.html#loop-labels

fn explain_loop_labels() {
    // Когда у нас есть вложенные циклы, иногда нам нужно выйти из всех циклов
    // по условию из внутреннего. Например, тут мы хотим выйти из внутреннего и внешнего цикла,
    // когда outer_counter == 5 и inner_counter == 0.
    let mut outer_counter = 10;
    loop {
        outer_counter -= 1;
        let mut inner_counter = 5;

        // Для этого обычно заводится специальный булевый флаг...
        let mut need_exit = false;
        loop {
            inner_counter -= 1;
            println!("inner counter = {inner_counter}");
            if outer_counter == 5 && inner_counter == 0 {
                // который выставляется в true, когда условие выполнилось
                need_exit = true;
            }
        }
        // чтобы во внешнем цикле можно было проверить выполнение условия
        if need_exit {
            break;
        }

        println!("outer counter = {outer_counter}");
        if outer_counter == 0 {
            break;
        }
    }

    // В Rust можно не добавлять переменные-флаги.
    // Чтобы решить эту задачу, циклам можно присваивать метки,
    // а затем использовать эти метки в break:
    let mut outer_counter = 10;
    // Внешнему циклу зададим метку с названием outer:
    'outer: loop {
        outer_counter -= 1;
        let mut inner_counter = 5;
        loop {
            inner_counter -= 1;
            println!("inner counter = {inner_counter}");
            if inner_counter == 0 {
                // Здесь мы после break пишем имя метки цикла,
                // из которого мы хотим выйти.
                // После этой команды мы выйдем как из внутреннего цилка,
                // так и из внешнего.
                break 'outer;
            }
        }
        println!("outer counter = {outer_counter}");
        if outer_counter == 0 {
            break;
        }
    }
}

//////////////////////////////////////////////////////////////////////////////////////////
/// Массив и вектор (Vec)
//////////////////////////////////////////////////////////////////////////////////////////

// https://doc.rust-lang.org/stable/std/primitive.array.html
// https://doc.rust-lang.org/stable/std/vec/struct.Vec.html

fn explain_arraya_and_vec() {
    // В языке есть статические массивы (arrays).
    // Задать их можно так.
    let arr = [1, 2, 3, 4, 5];
    // Это массив из пяти элементов с типом `i32`.
    // Массивы – статические, то есть их размер всегда фиксирован и должен быть
    // известен на момент компиляции.

    // Тип у массивов пишется так: `[T; N]`, где `T` - тип элементов, а `N` их число.
    let arr: [i32; 5] = [1, 2, 3, 4, 5];

    // Можно создать массив из элементов с одним значением
    let arr = [3.14f32; 5];
    // Получится массив `arr: [f32; 5] = [3.14f32, 3.14f32, 3.14f32, 3.14f32, 3.14f32];

    // Все о массивах: https://doc.rust-lang.org/stable/std/primitive.array.html

    // Статические массивы - это, конечно, хорошо. Например, благодаря "статичности" они располагаются
    // на стеке, что имеет свои плюсы.
    // Но чаще все-таки хочется иметь динамические массивы. Для этого аналогично плюсовому
    // std::vector<T> есть Vec<T>. Его данные располагаются в куче, а в структуре хранятся только три поля:
    // pointer, capacity, length - указатель на начало данных в куче, количество объектов, для которых
    // аллоцирована память, и количество инициализированных значений (length <= capacity).

    // Создать вектор можно разными способами.
    // Через макрос `vec`, перечисляя элементы как мы делали для массива.
    let v = vec![1, 2, 3, 4, 5];

    // Через макрос `vec`, указав инициализируемое значение и количество элементов.
    let v = vec![3.14f32; 5];

    // Создав пустой вектор и заполнив его значениями через функцию `push`.
    // Тип значений вектора будет выведен по типам аргументов в push.
    let mut v = Vec::new(); // Пустой вектор с capacity == 0.
    // Можно сразу при инциализации задать capacity:
    let mut v = Vec::with_capacity(3);
    v.push(1);
    v.push(2);
    v.push(3);
    println!("{:?}", v);
    v.clear();

    // Задать тип вектора явно можно следующими способами:
    let v: Vec<i32> = Vec::new();
    let v = Vec::<i32>::new();

    // Все о векторе: https://doc.rust-lang.org/stable/std/vec/struct.Vec.html
}

//////////////////////////////////////////////////////////////////////////////////////////
/// tuple, split, париснг числа из строки, чтение файлов, Option, Result
//////////////////////////////////////////////////////////////////////////////////////////

// Задача: дан рендж строк (например, "10-30") и путь к файлу,
// надо вывести строки с 10 по 30 заданного файла.
//
// Пример. Пусть запрошенные рендж это 10-30 и файл выглядит так:
// line 1
// line 2
// ...
// line n
//
// В результате должно быть:
// line 10
// line 11
// ...
// line 30

fn main() -> () {
    // Пусть аргументы пока будут фиксированные.
    // Чтобы считать их из аргументов командной строки,
    // можно воспользоваться std::env::args():
    // https://doc.rust-lang.org/stable/std/env/fn.args.html
    let (range, file_path) = ("3-7", "bible.txt");
    // Переменная объявленная выше имеет тип tuple размера 2
    // и типами &str, обозначается как (&str, &str).
    // Про tuple: https://doc.rust-lang.org/stable/std/primitive.tuple.html

    // Мы сразу же при объявлении распаковали tuple,
    // чтобы к каждому элементу можно было обращаться по своему имени.
    // Если так не делать, то аналогичный код выглядел бы так:
    // ```
    // let args = ("3-7", "bible.txt");
    // let range = args.0;
    // let file_path = args.1;
    // ```
    // Через `.` можно обращаться к конкретному элементу.

    // Дальше нам нужно разбить строку на две:
    // первое число в рендже и последнее.
    let (first_line_num, last_line_num) = range
        // Воспользуемся функцией split_once:
        // https://doc.rust-lang.org/stable/std/primitive.str.html#method.split_once
        .split_once('-')
        // split_once возвращает тип Option<(&str, &str)>
        // В кратце, Option это тип, который содержит одно из двух значений:
        // `None` (ничего) либо `Some((&str, &str))` (что-то, а именно значение типа `(&str, &str)`).
        // None может вернуться, если, например, разделителя не нашлось в строке.
        // Правильно обрабатывать оба случая, но пока мы вызовем функцию `unwrap`,
        // которая вернет значение, если там Some, и запаникует (остановит программу с ошибкой)
        // если там None.
        // https://doc.rust-lang.org/stable/std/option/enum.Option.html
        .unwrap();
    
    // Option<(&str, &str)>:
    //   None -> unwrap() -> panic
    //   Some((&str, &str)) -> unwrap() -> (&str, &str)

    // Строчки нужно сконвертировать в числа.
    let (first_line_num, last_line_num): (i32, i32) = (
        // Сделаем это через функцию от строки `parse`.
        // https://doc.rust-lang.org/stable/std/primitive.str.html#method.parse
        // Важно заметить, что мы нигде при вызове parse не указываем тип,
        // в который нужно распарсить строку. Тут приходит на помощь компилятор,
        // который видит, что в итоге мы хотим получить два числа: `(i32, i32)`.
        // Поэтому он может вывести тип даже generic-функции, коей является parse.
        first_line_num.parse().expect("could not prase int"),
        // `parse` в отличие от `split_once` возвращает вместо `Option<T>` тип `Result<T, Error>`.
        // Этот тип тоже может принимать только два значения:
        // Ok(T) либо Err(Error). Понятно почему может возникнуть Err.
        // Обрабатывать мы его сейчас не будем, хотя это было бы правильно.
        // Пока же просто попробуем получить значение через `unwrap`.
        // Если там Ok(i32), то получим i32, но если там Err, то программа запаникует.
        // Вместо `unwrap` также можно использовать `expect`, ему можно передать любую строку,
        // которая будет выведена при ошибке, а в остальном поведение аналогично `unwrap`.
        // https://doc.rust-lang.org/stable/std/result/enum.Result.html
        last_line_num.parse().unwrap(),
    );

    // Result<i32, Err>
    // i32 -> unwrap() -> i32
    // Err -> unwrap() -> panic

    // Прочитать контент файла можно через эту функцию
    // из крейта std::fs для работы с файловой системой.
    // Это самый простой способ и не очень эффективный.
    // https://doc.rust-lang.org/stable/std/fs/index.html
    let content = std::fs::read_to_string(file_path).unwrap();

    // Осталось проитерироваться по строкам файла.
    // У строк есть функция `lines()`, которая сплитит
    // строку по `\n` или `\r\n`. По результату можно проитерироваться.
    // https://doc.rust-lang.org/stable/std/primitive.str.html#method.lines
    // `enumerate()` оборачивает полученный интератор и вместо &str
    // возвращает tuple типа (usize, &str), где первое значение номер строки.
    // Прямо как в Python!
    // https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.enumerate
    for (idx, line) in content.lines().enumerate() {
        // Тип переменной idx – usize. Тип usize - это беззнаковое число,
        // размера 32 бита на 32-разрядных машинах и размера 64 бита на 64-разрядных.
        // Обычно этот тип используют для хранения индексов или адресов указателей
        // (именно поэтому размер привязан к архитектуре системы).
        // https://doc.rust-lang.org/stable/std/primitive.usize.html
        // Дальше мы его будем сравнивать с i32, поэтому его нужно привести к тому же типу:
        let idx = (idx + 1) as i32;
        if first_line_num <= idx && idx <= last_line_num {
            println!("{}", line);
        }
    }
}
